# -*- coding: utf-8 -*-
"""Breast Cancer-EDA-Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19oqsgLuHscA0rSa2puuBw396yZuriEEG

#About the Dataset
The Breast Cancer Wisconsin Diagnostic Dataset is a well-known dataset in the field of machine learning and medical research. It is often used for classification tasks to predict whether a tumor is malignant or benign based on various features computed from a digitized image of a fine needle aspirate (FNA) of a breast mass.

#Source

This dataset is available from multiple sources, but one of the most common and official sources is the UCI Machine Learning Repository. Here is a brief overview of the dataset:

Original Source: Dr. William H. Wolberg, University of Wisconsin.


Dataset Characteristics: Multivariate


Number of Instances: 569


Number of Attributes: 30 numeric, predictive attributes, and the class attribute.


Attribute Information: The attributes are computed from a digitized image of a fine needle aspirate (FNA) of a breast mass and describe characteristics of the cell nuclei present in the image. The features are:



* Radius (mean of distances from center to points on the perimeter)


* Texture (standard deviation of gray-scale values)


* Perimeter


* Area


*  Smoothness (local variation in radius lengths)


*  Compactness (perimeter^2 / area - 1.0)


*  Concavity (severity of concave portions of the contour)


* Concave points (number of concave portions of the contour)


* Symmetry


* Fractal dimension ("coastline approximation" - 1)

#Importing Necessary Libraries

We are required to importing the libraries so as to performing EDA. These include NumPy, Pandas, Matplotlib, and Seaborn.
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd # Pandas is a powerful library for data manipulation and analysis.
import numpy as np # NumPy is a powerful tool for numerical computations in Python.
import seaborn as sns # Seaborn is a statistical data visualization library based on Matplotlib
import matplotlib.pyplot as plt # Matplotlib is a comprehensive library for creating static, animated, and interactive visualizations in Python
# %matplotlib inline

"""#Loading the Dataset"""

df=pd.read_csv("brca.csv")

"""We will now read the data from a CSV file into a Pandas DataFrame Let us have a look at how our dataset looks like using df.head()"""

df # Displays the first 5 and last 5 rows of the dataset

df.columns # Displays the names of the columns

df.shape # Displays the total count of the Rows and Columns respectively.

df.describe(include='all')

"""#Rename the Columns

Creating a dictionary with the old column names as keys and the new short column names as values. Then, use the rename method to rename the columns.
"""

rename_dict = {
    'Unnamed: 0': 'id',
    'x.radius_mean': 'radius_mean',
    'x.texture_mean': 'texture_mean',
    'x.perimeter_mean': 'perimeter_mean',
    'x.area_mean': 'area_mean',
    'x.smoothness_mean': 'smoothness_mean',
    'x.compactness_mean': 'compactness_mean',
    'x.concavity_mean': 'concavity_mean',
    'x.concave_pts_mean': 'concave_pts_mean',
    'x.symmetry_mean': 'symmetry_mean',
    'x.fractal_dim_mean': 'fractal_dim_mean',
    'x.radius_se': 'radius_se',
    'x.texture_se': 'texture_se',
    'x.perimeter_se': 'perimeter_se',
    'x.area_se': 'area_se',
    'x.smoothness_se': 'smoothness_se',
    'x.compactness_se': 'compactness_se',
    'x.concavity_se': 'concavity_se',
    'x.concave_pts_se': 'concave_pts_se',
    'x.symmetry_se': 'symmetry_se',
    'x.fractal_dim_se': 'fractal_dim_se',
    'x.radius_worst': 'radius_worst',
    'x.texture_worst': 'texture_worst',
    'x.perimeter_worst': 'perimeter_worst',
    'x.area_worst': 'area_worst',
    'x.smoothness_worst': 'smoothness_worst',
    'x.compactness_worst': 'compactness_worst',
    'x.concavity_worst': 'concavity_worst',
    'x.concave_pts_worst': 'concave_pts_worst',
    'x.symmetry_worst': 'symmetry_worst',
    'x.fractal_dim_worst': 'fractal_dim_worst',
    'y': 'diagnosis'
}

# Rename columns using rename
df = df.rename(columns=rename_dict)

df.head() # checking the DataFrame to ensure the columns have been renamed correctly.

"""#Plotting histograms to understand the distribution of numerical features."""

import matplotlib.pyplot as plt

# Plot histograms for all numerical features
df.hist(figsize=(12, 12))
plt.show()

"""#Checking if there is any Null value in the Data

We will now check for missing values in our dataset. In case there are any missing entries, we will impute them with appropriate values (mode in case of categorical feature, and median or mean in case of numerical feature). We will use the isnull() function for this purpose.
"""

df.isnull().sum() # Displays the total count of the null valuesin the particular columns.

"""There is no null or missing value in the dataset."""

df.info() # Displays the total count of values present in the particular column along with the null count and data type.

"""#Checking for the Duplicate values

"""

# Check for duplicate rows
duplicate_rows = df[df.duplicated()]

if duplicate_rows.empty:
    print("No duplicate values found.")
else:
    print("Duplicate values found:")
    print(duplicate_rows)

"""##Creating a Mapping Dictionary
Create a dictionary to map the string values to integers.

Visualization techniques take input only integers and float, so it is necessary to convert the string values in integers or float
"""

# Mapping dictionary
diagnosis_mapping = {'B': 0, 'M': 1}

# Convert diagnosis column to integers
df['diagnosis'] = df['diagnosis'].map(diagnosis_mapping)

# Verify the conversion
print(df.head())

"""#Dropping unnecessary columns

The id column is not important as it just represents the number corresponding to the rows rows so we can drop the id column.
"""

# Drop the 'id' column
df = df.drop(columns=['id'])

df # Data frame after dropping the id column

df.corr() # computes the correlation matrix for the variables in the DataFrame df.

"""#Graphical representation

A histplot in Seaborn (or a histogram plot in general) is used to visualize the distribution of a dataset. It shows the frequency (or count) of data points that fall within specified bins or intervals.


"""

# Define custom colors
custom_colors = ["#FF5733", "#3366FF", "#33FF57"]  # Example colors, you can adjust as needed

# Plot the histogram with custom colors
sns.histplot(df['radius_mean'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['texture_mean'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['perimeter_mean'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['area_mean'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['smoothness_mean'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['compactness_mean'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['concavity_mean'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['concave_pts_mean'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['symmetry_mean'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['fractal_dim_mean'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['radius_se'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['texture_se'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['perimeter_se'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['area_se'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['smoothness_se'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['compactness_se'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['concavity_se'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['concave_pts_se'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['symmetry_se'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['fractal_dim_se'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['radius_worst'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['texture_worst'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['perimeter_worst'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['area_worst'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['smoothness_worst'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['compactness_worst'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['concavity_worst'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['concave_pts_worst'], kde=True, color="#FF5733", palette=custom_colors)

sns.histplot(df['symmetry_worst'], kde=True, color="#3366FF", palette=custom_colors)

sns.histplot(df['fractal_dim_worst'], kde=True, color="#33FF57", palette=custom_colors)

sns.histplot(df['diagnosis'], kde=True, color="#FF5733", palette=custom_colors)

# Compute the correlation matrix
corr_matrix = df.corr()

# Plot the heatmap
plt.figure(figsize=(20, 20))
sns.heatmap(corr_matrix, annot=True, fmt='.2f', cmap='coolwarm')
plt.show()

"""In the heatmap, the colors represent the strength and direction of the correlation coefficients between pairs of variables in the correlation matrix.

Correlation Coefficients:

The correlation coefficient ranges from -1 to 1.

1 indicates a perfect positive correlation.

-1 indicates a perfect negative correlation.

0 indicates no correlation.

Dark Red: Strong positive correlation (close to 1)

Dark Blue: Strong negative correlation (close to -1)

Light Colors (light red/light blue): Weak or no correlation (close to 0)
"""

# Plot box plots for all numerical features
plt.figure(figsize=(15, 10))
df.plot(kind='box', subplots=True, layout=(6, 6), sharex=False, sharey=False, figsize=(15, 15))
plt.show()

"""Here as we go through the boxplot visuals,


All the columns have outliers except concave_pts_worst
"""

# Pair plot with hue based on target variable
sns.pairplot(df, hue='diagnosis', diag_kind='kde')
plt.show()